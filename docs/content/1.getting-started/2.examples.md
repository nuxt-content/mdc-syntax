# Examples

Practical examples demonstrating common use cases for MDC Syntax.

## AI Chat Streaming

Real-time rendering of AI-generated markdown responses.

::code-group

```vue [Vue]
<script setup lang="ts">
import { ref } from 'vue'
import { parseStreamIncremental } from 'mdc-syntax/stream'
import { MDCRenderer } from 'mdc-syntax/vue'

interface Message {
  id: string
  role: 'user' | 'assistant'
  body: any
}

const messages = ref<Message[]>([])
const currentBody = ref({ type: 'minimark', value: [] })
const isStreaming = ref(false)
const input = ref('')

async function sendMessage() {
  if (!input.value.trim() || isStreaming.value) return

  // Add user message
  messages.value.push({
    id: Date.now().toString(),
    role: 'user',
    body: { type: 'minimark', value: [['p', {}, input.value]] }
  })

  const userInput = input.value
  input.value = ''
  isStreaming.value = true

  // Stream AI response
  const response = await fetch('/api/chat', {
    method: 'POST',
    body: JSON.stringify({ message: userInput }),
    headers: { 'Content-Type': 'application/json' }
  })

  for await (const result of parseStreamIncremental(response.body!)) {
    currentBody.value = result.body

    if (result.isComplete) {
      messages.value.push({
        id: Date.now().toString(),
        role: 'assistant',
        body: result.body
      })
      currentBody.value = { type: 'minimark', value: [] }
      isStreaming.value = false
    }
  }
}
</script>

<template>
  <div class="chat">
    <div class="messages">
      <div
        v-for="msg in messages"
        :key="msg.id"
        :class="['message', msg.role]"
      >
        <MDCRenderer :body="msg.body" />
      </div>

      <div v-if="isStreaming" class="message assistant streaming">
        <MDCRenderer :body="currentBody" :stream="true" />
        <span class="cursor" />
      </div>
    </div>

    <div class="input-area">
      <input
        v-model="input"
        :disabled="isStreaming"
        placeholder="Type a message..."
        @keyup.enter="sendMessage"
      />
      <button :disabled="isStreaming" @click="sendMessage">
        Send
      </button>
    </div>
  </div>
</template>
```

```tsx [React]
import { useState, useEffect } from 'react'
import { parseStreamIncremental } from 'mdc-syntax/stream'
import { MDCRenderer } from 'mdc-syntax/react'

interface Message {
  id: string
  role: 'user' | 'assistant'
  body: any
}

export default function Chat() {
  const [messages, setMessages] = useState<Message[]>([])
  const [currentBody, setCurrentBody] = useState({ type: 'minimark', value: [] })
  const [isStreaming, setIsStreaming] = useState(false)
  const [input, setInput] = useState('')

  async function sendMessage() {
    if (!input.trim() || isStreaming) return

    setMessages(prev => [...prev, {
      id: Date.now().toString(),
      role: 'user',
      body: { type: 'minimark', value: [['p', {}, input]] }
    }])

    const userInput = input
    setInput('')
    setIsStreaming(true)

    const response = await fetch('/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: userInput }),
      headers: { 'Content-Type': 'application/json' }
    })

    for await (const result of parseStreamIncremental(response.body!)) {
      setCurrentBody(result.body)

      if (result.isComplete) {
        setMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: 'assistant',
          body: result.body
        }])
        setCurrentBody({ type: 'minimark', value: [] })
        setIsStreaming(false)
      }
    }
  }

  return (
    <div className="chat">
      <div className="messages">
        {messages.map(msg => (
          <div key={msg.id} className={`message ${msg.role}`}>
            <MDCRenderer body={msg.body} />
          </div>
        ))}

        {isStreaming && (
          <div className="message assistant streaming">
            <MDCRenderer body={currentBody} stream={true} />
            <span className="cursor" />
          </div>
        )}
      </div>

      <div className="input-area">
        <input
          value={input}
          disabled={isStreaming}
          placeholder="Type a message..."
          onChange={e => setInput(e.target.value)}
          onKeyUp={e => e.key === 'Enter' && sendMessage()}
        />
        <button disabled={isStreaming} onClick={sendMessage}>
          Send
        </button>
      </div>
    </div>
  )
}
```

::

---

## Live Markdown Editor

Split-pane editor with real-time preview.

::code-group

```vue [Vue]
<script setup lang="ts">
import { ref, computed } from 'vue'
import { parse } from 'mdc-syntax'
import { MDCRenderer } from 'mdc-syntax/vue'

const content = ref(`# Welcome

This is a **live preview** markdown editor.

::alert{type="info"}
Edit the text on the left to see changes!
::

## Features

- Real-time preview
- MDC component support
- Syntax highlighting
`)

const result = computed(() => {
  return parse(content.value, { autoClose: true })
})
</script>

<template>
  <div class="editor-container">
    <div class="editor-pane">
      <textarea v-model="content" spellcheck="false" />
    </div>
    <div class="preview-pane">
      <MDCRenderer :body="result.body" />
    </div>
  </div>
</template>

<style scoped>
.editor-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  height: 100vh;
  gap: 1px;
  background: #e5e7eb;
}

.editor-pane textarea {
  width: 100%;
  height: 100%;
  padding: 1rem;
  border: none;
  resize: none;
  font-family: monospace;
  font-size: 14px;
  line-height: 1.6;
}

.preview-pane {
  padding: 1rem;
  overflow-y: auto;
  background: white;
}
</style>
```

```tsx [React]
import { useState, useMemo } from 'react'
import { parse } from 'mdc-syntax'
import { MDCRenderer } from 'mdc-syntax/react'

const defaultContent = `# Welcome

This is a **live preview** markdown editor.

::alert{type="info"}
Edit the text on the left to see changes!
::

## Features

- Real-time preview
- MDC component support
- Syntax highlighting
`

export default function Editor() {
  const [content, setContent] = useState(defaultContent)

  const result = useMemo(() => {
    return parse(content, { autoClose: true })
  }, [content])

  return (
    <div className="editor-container">
      <div className="editor-pane">
        <textarea
          value={content}
          onChange={e => setContent(e.target.value)}
          spellCheck={false}
        />
      </div>
      <div className="preview-pane">
        <MDCRenderer body={result.body} />
      </div>
    </div>
  )
}
```

::

---

## Documentation Site

Full-featured documentation page with TOC.

::code-group

```vue [Vue]
<script setup lang="ts">
import { parseAsync } from 'mdc-syntax'
import { MDCRenderer } from 'mdc-syntax/vue'

// Custom documentation components
import DocAlert from './components/DocAlert.vue'
import DocCodeGroup from './components/DocCodeGroup.vue'
import DocTabs from './components/DocTabs.vue'

const props = defineProps<{
  content: string
}>()

const components = {
  alert: DocAlert,
  'code-group': DocCodeGroup,
  tabs: DocTabs,
}

const result = await parseAsync(props.content, {
  highlight: {
    themes: {
      light: 'github-light',
      dark: 'github-dark'
    }
  }
})
</script>

<template>
  <div class="doc-layout">
    <aside class="doc-sidebar">
      <nav v-if="result.toc" class="toc">
        <h4>On this page</h4>
        <ul>
          <li v-for="link in result.toc.links" :key="link.id">
            <a :href="`#${link.id}`">{{ link.text }}</a>
            <ul v-if="link.children">
              <li v-for="child in link.children" :key="child.id">
                <a :href="`#${child.id}`">{{ child.text }}</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
    </aside>

    <main class="doc-content prose">
      <MDCRenderer :body="result.body" :components="components" />
    </main>
  </div>
</template>

<style scoped>
.doc-layout {
  display: grid;
  grid-template-columns: 250px 1fr;
  max-width: 1400px;
  margin: 0 auto;
}

.doc-sidebar {
  position: sticky;
  top: 0;
  height: 100vh;
  overflow-y: auto;
  padding: 2rem;
  border-right: 1px solid #e5e7eb;
}

.doc-content {
  padding: 2rem;
  max-width: 800px;
}

.toc ul {
  list-style: none;
  padding-left: 0;
}

.toc ul ul {
  padding-left: 1rem;
}

.toc a {
  color: #6b7280;
  text-decoration: none;
}

.toc a:hover {
  color: #111827;
}
</style>
```

```tsx [React]
import { useEffect, useState } from 'react'
import { parseAsync } from 'mdc-syntax'
import { MDCRenderer } from 'mdc-syntax/react'

import DocAlert from './components/DocAlert'
import DocCodeGroup from './components/DocCodeGroup'
import DocTabs from './components/DocTabs'

const components = {
  alert: DocAlert,
  'code-group': DocCodeGroup,
  tabs: DocTabs,
}

interface Props {
  content: string
}

export default function DocPage({ content }: Props) {
  const [result, setResult] = useState<any>(null)

  useEffect(() => {
    parseAsync(content, {
      highlight: {
        themes: {
          light: 'github-light',
          dark: 'github-dark'
        }
      }
    }).then(setResult)
  }, [content])

  if (!result) return <div>Loading...</div>

  return (
    <div className="doc-layout">
      <aside className="doc-sidebar">
        {result.toc && (
          <nav className="toc">
            <h4>On this page</h4>
            <ul>
              {result.toc.links.map((link: any) => (
                <li key={link.id}>
                  <a href={`#${link.id}`}>{link.text}</a>
                  {link.children && (
                    <ul>
                      {link.children.map((child: any) => (
                        <li key={child.id}>
                          <a href={`#${child.id}`}>{child.text}</a>
                        </li>
                      ))}
                    </ul>
                  )}
                </li>
              ))}
            </ul>
          </nav>
        )}
      </aside>

      <main className="doc-content prose">
        <MDCRenderer body={result.body} components={components} />
      </main>
    </div>
  )
}
```

::

---

## Static Site Generator

Process markdown files for static site generation.

```typescript
import { readdir, readFile, writeFile, mkdir } from 'node:fs/promises'
import { join, dirname, basename } from 'node:path'
import { parseAsync, renderHTML } from 'mdc-syntax'

interface ProcessedFile {
  slug: string
  html: string
  frontmatter: any
  toc: any
}

async function processMarkdownFile(filePath: string): Promise<ProcessedFile> {
  const content = await readFile(filePath, 'utf-8')

  const result = await parseAsync(content, {
    highlight: {
      themes: { light: 'github-light', dark: 'github-dark' }
    }
  })

  return {
    slug: basename(filePath, '.md'),
    html: renderHTML(result.body),
    frontmatter: result.data,
    toc: result.toc
  }
}

async function buildSite(srcDir: string, outDir: string) {
  const files = await readdir(srcDir)
  const mdFiles = files.filter(f => f.endsWith('.md'))

  const processed = await Promise.all(
    mdFiles.map(file => processMarkdownFile(join(srcDir, file)))
  )

  // Ensure output directory exists
  await mkdir(outDir, { recursive: true })

  // Generate HTML files
  for (const page of processed) {
    const html = generatePageHTML(page)
    await writeFile(join(outDir, `${page.slug}.html`), html)
  }

  // Generate index
  const index = generateIndexHTML(processed)
  await writeFile(join(outDir, 'index.html'), index)

  console.log(`Built ${processed.length} pages`)
}

function generatePageHTML(page: ProcessedFile): string {
  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>${page.frontmatter.title || page.slug}</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <nav class="toc">
    ${generateTOCHTML(page.toc)}
  </nav>
  <main class="content">
    ${page.html}
  </main>
</body>
</html>`
}

function generateTOCHTML(toc: any): string {
  if (!toc?.links?.length) return ''

  return `<ul>
    ${toc.links.map((link: any) => `
      <li>
        <a href="#${link.id}">${link.text}</a>
        ${link.children ? generateTOCHTML({ links: link.children }) : ''}
      </li>
    `).join('')}
  </ul>`
}

function generateIndexHTML(pages: ProcessedFile[]): string {
  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Documentation</title>
</head>
<body>
  <h1>Documentation</h1>
  <ul>
    ${pages.map(p => `
      <li>
        <a href="${p.slug}.html">
          ${p.frontmatter.title || p.slug}
        </a>
      </li>
    `).join('')}
  </ul>
</body>
</html>`
}

// Run
buildSite('./content', './dist')
```

---

## Blog with MDC Components

Blog post with custom components.

**Custom Alert Component:**

::code-group

```vue [Vue - Alert.vue]
<script setup lang="ts">
defineProps<{
  type?: 'info' | 'warning' | 'error' | 'success'
}>()
</script>

<template>
  <div :class="['alert', `alert-${type || 'info'}`]" role="alert">
    <div class="alert-icon">
      <span v-if="type === 'info'">i</span>
      <span v-else-if="type === 'warning'">!</span>
      <span v-else-if="type === 'error'">x</span>
      <span v-else-if="type === 'success'">v</span>
    </div>
    <div class="alert-content">
      <slot />
    </div>
  </div>
</template>

<style scoped>
.alert {
  display: flex;
  gap: 0.75rem;
  padding: 1rem;
  border-radius: 0.5rem;
  margin: 1rem 0;
}

.alert-info { background: #dbeafe; border: 1px solid #3b82f6; }
.alert-warning { background: #fef3c7; border: 1px solid #f59e0b; }
.alert-error { background: #fee2e2; border: 1px solid #ef4444; }
.alert-success { background: #d1fae5; border: 1px solid #10b981; }
</style>
```

```tsx [React - Alert.tsx]
import React from 'react'

interface AlertProps {
  type?: 'info' | 'warning' | 'error' | 'success'
  children: React.ReactNode
}

export default function Alert({ type = 'info', children }: AlertProps) {
  const icons = { info: 'i', warning: '!', error: 'x', success: 'v' }

  return (
    <div className={`alert alert-${type}`} role="alert">
      <div className="alert-icon">{icons[type]}</div>
      <div className="alert-content">{children}</div>
    </div>
  )
}
```

::

**Blog Post Component:**

::code-group

```vue [Vue - BlogPost.vue]
<script setup lang="ts">
import { parse } from 'mdc-syntax'
import { MDCRenderer } from 'mdc-syntax/vue'
import Alert from './Alert.vue'
import CodeBlock from './CodeBlock.vue'

const props = defineProps<{
  content: string
}>()

const components = {
  alert: Alert,
  pre: CodeBlock,
}

const result = parse(props.content)
</script>

<template>
  <article class="blog-post">
    <header>
      <h1>{{ result.data.title }}</h1>
      <div class="meta">
        <time>{{ result.data.date }}</time>
        <span>{{ result.data.author }}</span>
      </div>
    </header>

    <div class="content prose">
      <MDCRenderer :body="result.body" :components="components" />
    </div>

    <footer>
      <div class="tags">
        <span
          v-for="tag in result.data.tags"
          :key="tag"
          class="tag"
        >
          {{ tag }}
        </span>
      </div>
    </footer>
  </article>
</template>
```

```tsx [React - BlogPost.tsx]
import { useMemo } from 'react'
import { parse } from 'mdc-syntax'
import { MDCRenderer } from 'mdc-syntax/react'
import Alert from './Alert'
import CodeBlock from './CodeBlock'

const components = {
  alert: Alert,
  pre: CodeBlock,
}

interface Props {
  content: string
}

export default function BlogPost({ content }: Props) {
  const result = useMemo(() => parse(content), [content])

  return (
    <article className="blog-post">
      <header>
        <h1>{result.data.title}</h1>
        <div className="meta">
          <time>{result.data.date}</time>
          <span>{result.data.author}</span>
        </div>
      </header>

      <div className="content prose">
        <MDCRenderer body={result.body} components={components} />
      </div>

      <footer>
        <div className="tags">
          {result.data.tags?.map((tag: string) => (
            <span key={tag} className="tag">{tag}</span>
          ))}
        </div>
      </footer>
    </article>
  )
}
```

::

---

## Server-Side Rendering (SSR)

Nuxt 3 example with SSR.

```vue
<!-- pages/docs/[...slug].vue -->
<script setup lang="ts">
import { parseAsync } from 'mdc-syntax'
import { MDCRenderer } from 'mdc-syntax/vue'

const route = useRoute()
const slug = (route.params.slug as string[]).join('/')

// Fetch and parse on server
const { data: result } = await useAsyncData(
  `doc-${slug}`,
  async () => {
    const content = await $fetch(`/api/docs/${slug}`)
    return parseAsync(content, {
      highlight: true
    })
  }
)

// SEO
useSeoMeta({
  title: result.value?.data?.title,
  description: result.value?.data?.description,
})
</script>

<template>
  <div v-if="result">
    <h1>{{ result.data.title }}</h1>
    <MDCRenderer :body="result.body" />
  </div>
</template>
```

---

## Progress Tracking

Show progress while streaming large documents.

```vue
<script setup lang="ts">
import { ref, computed } from 'vue'
import { parseStreamIncremental } from 'mdc-syntax/stream'
import { MDCRenderer } from 'mdc-syntax/vue'

const body = ref({ type: 'minimark', value: [] })
const bytesReceived = ref(0)
const totalBytes = ref(0)
const isComplete = ref(false)

const progress = computed(() => {
  if (totalBytes.value === 0) return 0
  return Math.round((bytesReceived.value / totalBytes.value) * 100)
})

async function loadDocument(url: string) {
  const response = await fetch(url)

  const contentLength = response.headers.get('content-length')
  if (contentLength) {
    totalBytes.value = parseInt(contentLength)
  }

  for await (const result of parseStreamIncremental(response.body!)) {
    bytesReceived.value += result.chunk.length
    body.value = result.body

    if (result.isComplete) {
      isComplete.value = true
    }
  }
}

loadDocument('/api/large-document')
</script>

<template>
  <div>
    <div v-if="!isComplete" class="progress">
      <div class="progress-bar">
        <div class="progress-fill" :style="{ width: `${progress}%` }" />
      </div>
      <span>Loading... {{ progress }}%</span>
    </div>

    <MDCRenderer :body="body" :stream="!isComplete" />
  </div>
</template>
```

---

## Custom Component Library

Creating a reusable component library.

```typescript
// components/index.ts
import Alert from './Alert.vue'
import Card from './Card.vue'
import Tabs from './Tabs.vue'
import CodeGroup from './CodeGroup.vue'
import Callout from './Callout.vue'
import Badge from './Badge.vue'
import Button from './Button.vue'

export const mdcComponents = {
  // Block components
  alert: Alert,
  card: Card,
  tabs: Tabs,
  'code-group': CodeGroup,
  callout: Callout,

  // Inline components
  badge: Badge,
  button: Button,
}

// Type for component props
export interface MDCComponentProps {
  __node?: any
}

export interface AlertProps extends MDCComponentProps {
  type?: 'info' | 'warning' | 'error' | 'success'
}

export interface CardProps extends MDCComponentProps {
  title?: string
  icon?: string
}

export interface BadgeProps extends MDCComponentProps {
  color?: string
  variant?: 'solid' | 'outline'
}
```

**Usage:**

```vue
<script setup lang="ts">
import { parse } from 'mdc-syntax'
import { MDCRenderer } from 'mdc-syntax/vue'
import { mdcComponents } from '@/components'

const result = parse(content)
</script>

<template>
  <MDCRenderer :body="result.body" :components="mdcComponents" />
</template>
```

---

## See Also

- [Parse API](/api/parse) - Parsing functions reference
- [Vue Renderer](/rendering/vue-renderer) - Vue rendering
- [React Rendering](/rendering/react) - React rendering
- [Markdown Syntax](/syntax/markdown) - MDC syntax reference
