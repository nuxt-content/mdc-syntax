# Auto-Close API

The auto-close API provides utilities for handling incomplete or partial MDC content, which is especially useful for streaming scenarios where content arrives incrementally.

## Overview

When parsing streaming content (like AI-generated text), the content is often incomplete with unclosed markdown syntax or MDC components. The auto-close utilities automatically detect and close these unclosed elements, ensuring valid parsing at every chunk.

## Functions

### `autoCloseMarkdown(markdown: string): string`

Automatically closes unclosed markdown inline syntax and MDC components.

**Parameters:**
- `markdown` - The markdown content (potentially partial/incomplete)

**Returns:** The markdown with auto-closed syntax

**Example:**

```typescript
import { autoCloseMarkdown } from 'mdc-syntax'

// Auto-close bold syntax
const partial = '**bold text'
const closed = autoCloseMarkdown(partial)
console.log(closed) // '**bold text**'

// Auto-close italic syntax
const italic = '*italic text'
const closedItalic = autoCloseMarkdown(italic)
console.log(closedItalic) // '*italic text*'

// Auto-close MDC component
const component = '::alert{type="info"}\nImportant message'
const closedComponent = autoCloseMarkdown(component)
console.log(closedComponent)
// '::alert{type="info"}\nImportant message\n::'

// Auto-close nested components
const nested = ':::parent\n::child\nContent'
const closedNested = autoCloseMarkdown(nested)
console.log(closedNested)
// ':::parent\n::child\nContent\n::\n:::'
```

### `detectUnclosedSyntax(markdown: string): UnclosedSyntaxInfo`

Detects unclosed syntax without modifying the content. Useful for validation or showing warnings.

**Parameters:**
- `markdown` - The markdown content to check

**Returns:** `UnclosedSyntaxInfo` object:
```typescript
{
  hasUnclosed: boolean
  unclosedInline: string[]
  unclosedComponents: Array<{
    markerCount: number
    name: string
  }>
}
```

**Example:**

```typescript
import { detectUnclosedSyntax } from 'mdc-syntax'

const content = '::card\nText with **bold'
const detection = detectUnclosedSyntax(content)

console.log(detection)
// {
//   hasUnclosed: true,
//   unclosedInline: ['**bold**'],
//   unclosedComponents: [{ markerCount: 2, name: 'card' }]
// }

// Check if content is complete
if (detection.hasUnclosed) {
  console.log('Warning: Content has unclosed syntax')
  console.log(`Unclosed inline: ${detection.unclosedInline.join(', ')}`)
  console.log(`Unclosed components: ${detection.unclosedComponents.map(c => c.name).join(', ')}`)
}
```

## Streaming Integration

The auto-close utilities are **automatically integrated** into `parseStreamIncremental`, so you don't need to call them manually:

```typescript
import { parseStreamIncremental } from 'mdc-syntax/stream'

// Auto-close is automatically applied!
for await (const result of parseStreamIncremental(stream)) {
  if (!result.isComplete) {
    // Each intermediate result has auto-closed syntax
    renderContent(result.body)
  }
}
```

However, you can use them manually if needed:

```typescript
import { autoCloseMarkdown, parse } from 'mdc-syntax'

async function* parseStreamWithManualAutoClose(stream) {
  let accumulated = ''

  for await (const chunk of stream) {
    accumulated += chunk.toString()

    // Manually apply auto-close
    const closed = autoCloseMarkdown(accumulated)
    const parsed = parse(closed)

    yield parsed
  }
}
```

## Supported Syntax

### Inline Markdown

The auto-close API handles these inline markdown syntaxes:

| Syntax | Example | Auto-closed |
|--------|---------|-------------|
| Bold | `**text` | `**text**` |
| Italic | `*text` | `*text*` |
| Code | `` `code `` | `` `code` `` |
| Strikethrough | `~~text` | `~~text~~` |
| Link | `[text](url` | `[text](url)` |
| Image | `![alt](url` | `![alt](url)` |

**Example:**

```typescript
const examples = [
  '**bold',
  '*italic',
  '`code',
  '~~strike',
  '[link](url',
  '![image](url'
]

examples.forEach((text) => {
  console.log(autoCloseMarkdown(text))
})
// **bold**
// *italic*
// `code`
// ~~strike~~
// [link](url)
// ![image](url)
```

### MDC Components

Block components are automatically closed based on their marker count:

```typescript
// Single marker (not a block component, no closing needed)
autoCloseMarkdown(':inline-component')
// ':inline-component'

// Double marker (block component)
autoCloseMarkdown('::alert\nContent')
// '::alert\nContent\n::'

// Triple marker (nested component)
autoCloseMarkdown(':::card\nContent')
// ':::card\nContent\n:::'

// Nested components
autoCloseMarkdown('::::outer\n:::inner\n::component')
// '::::outer\n:::inner\n::component\n::\n:::\n::::'
```

### Props and Attributes

Components with props are handled correctly:

```typescript
// Props
autoCloseMarkdown('::alert{type="info" title="Note"}')
// '::alert{type="info" title="Note"}\n::'

// Content with props
autoCloseMarkdown('::card{class="primary"}\nContent here')
// '::card{class="primary"}\nContent here\n::'

// YAML props
autoCloseMarkdown(`::component
---
key: value
---
Content`)
// '::component\n---\nkey: value\n---\nContent\n::'
```

## Use Cases

### 1. AI Streaming Content

When streaming AI-generated markdown, content arrives in chunks and may be incomplete:

```typescript
import { autoCloseMarkdown, parse } from 'mdc-syntax'

let accumulated = ''

socket.on('chunk', (chunk) => {
  accumulated += chunk

  // Auto-close before parsing to ensure valid AST
  const closed = autoCloseMarkdown(accumulated)
  const parsed = parse(closed)

  // Update UI with valid parsed content
  renderContent(parsed.body)
})

socket.on('end', () => {
  // Final parse with complete content
  const final = parse(accumulated)
  renderFinalContent(final.body)
})
```

### 2. Real-time Markdown Editor

Show live preview while user types:

```typescript
import { autoCloseMarkdown, parse } from 'mdc-syntax'

const editor = document.querySelector('#markdown-editor')
const preview = document.querySelector('#preview')

editor.addEventListener('input', (e) => {
  const content = e.target.value

  // Auto-close for valid preview even with incomplete syntax
  const closed = autoCloseMarkdown(content)
  const parsed = parse(closed)

  // Render preview
  preview.innerHTML = renderToHTML(parsed.body)
})
```

### 3. Validation Warnings

Show warnings to users about incomplete syntax:

```typescript
import { detectUnclosedSyntax } from 'mdc-syntax'

function validateMarkdown(content: string) {
  const detection = detectUnclosedSyntax(content)

  if (detection.hasUnclosed) {
    const warnings = []

    if (detection.unclosedInline.length > 0) {
      warnings.push(`Unclosed inline syntax: ${detection.unclosedInline.join(', ')}`)
    }

    if (detection.unclosedComponents.length > 0) {
      const components = detection.unclosedComponents.map(c =>
        `${c.name} (${':'.repeat(c.markerCount)})`
      )
      warnings.push(`Unclosed components: ${components.join(', ')}`)
    }

    return { valid: false, warnings }
  }

  return { valid: true, warnings: [] }
}

// Usage
const result = validateMarkdown('::alert\n**bold text')
console.log(result)
// {
//   valid: false,
//   warnings: [
//     'Unclosed inline syntax: **bold**',
//     'Unclosed components: alert (::)'
//   ]
// }
```

### 4. Incremental File Upload

Parse content as file uploads:

```typescript
import { autoCloseMarkdown, parse } from 'mdc-syntax'

async function uploadAndParse(file: File) {
  const chunkSize = 64 * 1024 // 64KB chunks
  let offset = 0
  let accumulated = ''

  while (offset < file.size) {
    const chunk = file.slice(offset, offset + chunkSize)
    const text = await chunk.text()
    accumulated += text

    // Parse with auto-close for progress display
    const closed = autoCloseMarkdown(accumulated)
    const parsed = parse(closed)

    updateProgress({
      percent: (offset / file.size) * 100,
      preview: parsed.body
    })

    offset += chunkSize
  }

  // Final parse
  return parse(accumulated)
}
```

## Advanced Examples

### Combining with Custom Closing Logic

```typescript
import { autoCloseMarkdown, detectUnclosedSyntax } from 'mdc-syntax'

function smartAutoClose(markdown: string, options = {}) {
  const detection = detectUnclosedSyntax(markdown)

  if (!detection.hasUnclosed) {
    return markdown // Already complete
  }

  // Apply auto-close
  let closed = autoCloseMarkdown(markdown)

  // Custom logic: add comments about auto-closed elements
  if (options.addComments) {
    if (detection.unclosedInline.length > 0) {
      closed += `\n<!-- Auto-closed: ${detection.unclosedInline.join(', ')} -->`
    }
  }

  return closed
}
```

### Progressive Enhancement

```typescript
import { autoCloseMarkdown, detectUnclosedSyntax, parse } from 'mdc-syntax'

function parseWithMetadata(markdown: string) {
  const detection = detectUnclosedSyntax(markdown)
  const closed = autoCloseMarkdown(markdown)
  const parsed = parse(closed)

  return {
    ast: parsed.body,
    data: parsed.data,
    toc: parsed.toc,
    metadata: {
      isComplete: !detection.hasUnclosed,
      autoClosedInline: detection.unclosedInline,
      autoClosedComponents: detection.unclosedComponents,
      originalLength: markdown.length,
      closedLength: closed.length
    }
  }
}

// Usage
const result = parseWithMetadata('::alert\n**Bold text\n\nMore content')
console.log(result.metadata)
// {
//   isComplete: false,
//   autoClosedInline: ['**Bold text**'],
//   autoClosedComponents: [{ markerCount: 2, name: 'alert' }],
//   originalLength: 34,
//   closedLength: 40
// }
```

## Performance Considerations

1. **Auto-close is fast**: The algorithm is optimized and runs in O(n) time where n is the length of the content.

2. **Call once per chunk**: In streaming scenarios, call `autoCloseMarkdown` once per chunk, not for every character.

3. **Cache detection results**: If you need both detection and auto-close, use `detectUnclosedSyntax` first and cache the result.

```typescript
// Good: Call once per chunk
for await (const chunk of stream) {
  accumulated += chunk
  const closed = autoCloseMarkdown(accumulated)
  render(parse(closed))
}

// Avoid: Calling for every character
for (const char of text) {
  accumulated += char
  const closed = autoCloseMarkdown(accumulated) // Too frequent!
  render(parse(closed))
}
```

## Limitations

1. **Complex nested structures**: Very deeply nested components (>10 levels) may have edge cases.

2. **Custom syntax**: Only standard MDC and markdown syntax is supported. Custom extensions need separate handling.

3. **Ambiguous cases**: Some ambiguous syntax may be closed in unexpected ways:
   ```typescript
   // This could be interpreted multiple ways
   autoCloseMarkdown('**bold *italic')
   // Currently closes as: '**bold *italic***'
   ```

## See Also

- [Parse API](/api/parse) - Main parsing functions
- [Vue Renderer](/rendering/vue-renderer) - Vue integration
- [Examples](/getting-started/examples) - Real-world usage patterns
